#!/usr/bin/env python3
"""
TagFootageByCSV.py

DaVinci Resolve script for automatic tag and group application to video clips.

Functions:
- Reads metadata.csv file generated by create_metadata.py
- Automatically applies colors to clips based on color profiles
- Creates logical groups to facilitate batch color grading
- Compatible with automatic "Footage" bin detection

Installation:
Place this file in DaVinci Resolve utility scripts directory:
- Windows: %APPDATA%\Blackmagic Design\DaVinci Resolve\Fusion\Scripts\Utility\
- macOS: ~/Library/Application Support/Blackmagic Design/DaVinci Resolve/Fusion/Scripts/Utility/
- Linux: ~/.local/share/DaVinciResolve/Fusion/Scripts/Utility/

Usage:
In DaVinci Resolve: Workspace > Scripts > Utility > TagFootageByCSV
Open Console (Workspace > Console) to see execution progress.

Prerequisites:
- metadata.csv file in project root folder
- Clips imported in DaVinci Resolve with bins created for subfolders
"""
import os, csv, sys

FOOTAGE_BIN_CANDIDATES = ["footage", "footages"]
VALID_COLORS = {"Red","Yellow","Green","Cyan","Blue","Purple","Pink","Fuchsia","Rose","Lavender","Brown","Olive","Orange","Tan","Teal","Violet","Magenta","Sand"}
FALLBACK_COLOR_CYCLE = ["Yellow","Cyan","Green","Blue","Purple","Olive","Pink","Brown"]
GROUP_TO_COLOR_DEFAULTS = {"S-Log3":"Yellow","D-Log":"Cyan","HLG":"Green","Rec709":"Blue","CineLikeD":"Purple","GoProFlat":"Olive"}
COLORSPACE_TO_GROUP = {"S-Log3":"S-Log3","SLog3":"S-Log3","D-Log":"D-Log","DLog":"D-Log","HLG":"HLG","BT.709":"Rec709","Rec709":"Rec709","709":"Rec709"}

def log(*a): print("[TagCSV v2]", *a)

def get_resolve():
    try:
        if 'resolve' in globals() and globals()['resolve'] is not None:
            return globals()['resolve']
    except Exception: pass
    try:
        if 'bmd' in globals():
            app = bmd.scriptapp("Resolve")
            if app: return app
    except Exception: pass
    try:
        if 'bmd' in globals():
            fu = bmd.scriptapp("Fusion")
            if fu:
                app = getattr(fu, "GetResolve", lambda: None)()
                if app: return app
    except Exception: pass
    return None

def find_bin_recursive(folder, names_lower):
    if folder is None: return None
    name = (folder.GetName() or "").strip().lower()
    if name in names_lower: return folder
    for sub in (folder.GetSubFolders() or {}).values():
        f = find_bin_recursive(sub, names_lower)
        if f: return f
    return None

def iter_items(folder):
    for it in (folder.GetClips() or {}).values():
        yield it
    for sub in (folder.GetSubFolders() or {}).values():
        for it in iter_items(sub):
            yield it

def common_root(paths):
    try:
        return os.path.commonpath(paths)
    except Exception:
        return os.path.dirname(paths[0]) if paths else None

def load_csv(csv_path):
    rules = []
    with open(csv_path, newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for i,row in enumerate(reader, start=1):
            r = { (k.strip().lower() if isinstance(k,str) else k) : (v.strip() if isinstance(v,str) else v)
                  for k,v in row.items() }
            rules.append(r)
    return rules

def decide_group_and_color(row):
    group = row.get("group_name","") or ""
    color = row.get("clip_color","") or ""
    if not group:
        cs = row.get("color_space","") or ""
        group = COLORSPACE_TO_GROUP.get(cs, "") if cs else ""
    if not color and group:
        color = GROUP_TO_COLOR_DEFAULTS.get(group, "")
    return group or "", color or ""

def normalize_color(name):
    if not name: return ""
    if len(name) > 1: name = name[0].upper() + name[1:].lower()
    else: name = name.upper()
    aliases = {"Fuschia":"Fuchsia"}; name = aliases.get(name, name)
    return name if name in VALID_COLORS else ""

def main():
    log("start")
    resolve = get_resolve()
    log("resolve obj:", resolve)
    if not resolve:
        log("FAIL: API indisponible"); return

    proj = resolve.GetProjectManager().GetCurrentProject()
    log("project:", proj.GetName() if proj else None)
    if not proj: log("FAIL: aucun projet"); return

    mp = proj.GetMediaPool()
    root = mp.GetRootFolder()
    names = set([n.lower() for n in FOOTAGE_BIN_CANDIDATES])
    footage = find_bin_recursive(root, names) or root
    log("bin ciblé:", footage.GetName() if footage else None)

    items = list(iter_items(footage))
    log("clips dans bin:", len(items))
    if not items:
        log("Aucun clip. As-tu importé Footage via Media Storage > Add Folder and Subfolders ?")
        return

    file_paths = []
    for it in items:
        p = it.GetClipProperty("File Path")
        if p: file_paths.append(p)
    file_paths = [p for p in file_paths if p]
    if not file_paths:
        log("FAIL: aucun chemin lisible"); return

    for p in file_paths[:5]:
        log("exemple path:", p)

    root_path = common_root(file_paths)
    log("root_path détecté:", root_path)
    if not root_path:
        log("FAIL: root_path None"); return

    csv_path = os.path.join(root_path, "metadata.csv")
    log("csv attendu:", csv_path)
    if not os.path.isfile(csv_path):
        log("FAIL: metadata.csv introuvable"); return

    rules = load_csv(csv_path)
    log("règles CSV:", len(rules))
    if not rules:
        log("FAIL: CSV vide"); return

    # index CSV
    rules_by_relpath = {}
    rules_by_basename = {}
    for r in rules:
        fn = (r.get("filename","") or "").lower()
        rp = (r.get("relpath","") or "").replace("\\","/").lstrip("/").lower()
        if fn: rules_by_basename.setdefault(fn, []).append(r)
        if rp: rules_by_relpath[rp] = r
    log("index CSV: basenames:", len(rules_by_basename), "relpaths:", len(rules_by_relpath))

    # index MP
    mp_by_relpath = {}
    mp_by_basename = {}
    for it in items:
        fp = it.GetClipProperty("File Path") or ""
        if not fp: continue
        bn = os.path.basename(fp).lower()
        mp_by_basename.setdefault(bn, []).append(it)
        try:
            rel = os.path.relpath(fp, root_path).replace("\\","/").lower()
            mp_by_relpath[rel] = it
        except Exception:
            pass
    log("index MP: basenames:", len(mp_by_basename), "relpaths:", len(mp_by_relpath))

    # timeline
    tl = proj.GetCurrentTimeline()
    if not tl:
        log("Pas de timeline active → j'en crée une avec tous les clips du bin.")
        try:
            new_tl = mp.CreateTimelineFromClips("Footage_All", items)
            if new_tl:
                proj.SetCurrentTimeline(new_tl)
                tl = new_tl
                log("timeline créée:", tl.GetName())
        except Exception as e:
            log("Échec création timeline:", e)
    tl_index = {}
    if tl:
        try:
            v = tl.GetTrackCount("video") or 0
            for tr in range(1, v+1):
                for _, ti in (tl.GetItemsInTrack("video", tr) or {}).items():
                    mpi = ti.GetMediaPoolItem()
                    if mpi:
                        p = mpi.GetClipProperty("File Path") or ""
                        if p:
                            tl_index[os.path.basename(p).lower()] = ti
            log("items sur timeline indexés:", len(tl_index))
        except Exception as e:
            log("warn: timeline index:", e)

    # groups
    existing_groups = {}
    try:
        for g in (proj.GetColorGroupsList() or []):
            existing_groups[g.GetName()] = g
        log("color groups existants:", list(existing_groups.keys()))
    except Exception as e:
        log("warn: GetColorGroupsList:", e)

    def ensure_group(name):
        if not name: return None
        if name in existing_groups: return existing_groups[name]
        try:
            g = proj.AddColorGroup(name)
            if g:
                existing_groups[name] = g
                log("créé color group:", name)
                return g
        except Exception as e:
            log("warn: AddColorGroup:", name, e)
        return None

    applied = 0
    fallback_idx = 0
    matched = 0

    for r in rules:
        target = None
        rp = (r.get("relpath","") or "").replace("\\","/").lstrip("/").lower()
        fn = (r.get("filename","") or "").lower()

        if rp and rp in mp_by_relpath:
            target = mp_by_relpath[rp]
        elif fn:
            cands = mp_by_basename.get(fn, [])
            if len(cands) == 1:
                target = cands[0]
            elif len(cands) > 1:
                src = (r.get("source","") or "").lower()
                if src:
                    for it in cands:
                        p = (it.GetClipProperty("File Path") or "").lower()
                        if ("/"+src+"/") in p or p.endswith("/"+src+"/"+fn):
                            target = it; break
                if not target and cands:
                    target = cands[0]

        if not target:
            continue
        matched += 1

        group, color = decide_group_and_color(r)
        color = normalize_color(color)
        if not color:
            color = FALLBACK_COLOR_CYCLE[fallback_idx % len(FALLBACK_COLOR_CYCLE)]
            fallback_idx += 1

        fp = target.GetClipProperty("File Path") or ""
        log("apply →", os.path.relpath(fp, root_path) if root_path else fp, "| group:", group or "-", "| color:", color)

        try: target.SetClipColor(color)
        except Exception as e: log("warn: bin.SetClipColor:", e)

        if tl:
            bn = os.path.basename(fp).lower()
            ti = tl_index.get(bn)
            if ti:
                try: ti.SetClipColor(color)
                except Exception as e: log("warn: tl.SetClipColor:", e)
                if group:
                    g = ensure_group(group)
                    if g:
                        try: ti.AssignToColorGroup(g)
                        except Exception as e: log("warn: AssignToColorGroup:", e)

        applied += 1

    log("matched CSV→clips:", matched, " | applied:", applied)
    if not tl:
        log("NOTE: pas de timeline active → les Color Groups ne s'appliquent pas aux timeline items.")
    log("done.")

if __name__ == "__main__":
    main()
